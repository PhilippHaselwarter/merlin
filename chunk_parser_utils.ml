type token = Chunk_parser.token

let token_to_string =
  let open Chunk_parser in function
    | AMPERAMPER -> "AMPERAMPER"
    | AMPERSAND -> "AMPERSAND"
    | AND -> "AND"
    | AS -> "AS"
    | ASSERT -> "ASSERT"
    | BACKQUOTE -> "BACKQUOTE"
    | BANG -> "BANG"
    | BAR -> "BAR"
    | BARBAR -> "BARBAR"
    | BARRBRACKET -> "BARRBRACKET"
    | BEGIN -> "BEGIN"
    | CHAR c -> "CHAR(" ^ String.escaped (String.make 1 c) ^ ")"
    | CLASS -> "CLASS"
    | COLON -> "COLON"
    | COLONCOLON -> "COLONCOLON"
    | COLONEQUAL -> "COLONEQUAL"
    | COLONGREATER -> "COLONGREATER"
    | COMMA -> "COMMA"
    | CONSTRAINT -> "CONSTRAINT"
    | DO -> "DO"
    | DONE -> "DONE"
    | DOT -> "DOT"
    | DOTDOT -> "DOTDOT"
    | DOWNTO -> "DOWNTO"
    | ELSE -> "ELSE"
    | END -> "END"
    | EOF -> "EOF"
    | EQUAL -> "EQUAL"
    | EXCEPTION -> "EXCEPTION"
    | EXTERNAL -> "EXTERNAL"
    | FALSE -> "FALSE"
    | FLOAT s -> "FLOAT(" ^ String.escaped s ^ ")"
    | FOR -> "FOR"
    | FUN -> "FUN"
    | FUNCTION -> "FUNCTION"
    | FUNCTOR -> "FUNCTOR"
    | GREATER -> "GREATER"
    | GREATERRBRACE -> "GREATERRBRACE"
    | GREATERRBRACKET -> "GREATERRBRACKET"
    | IF -> "IF"
    | IN -> "IN"
    | INCLUDE -> "INCLUDE"
    | INFIXOP0 s -> "INFIXOP0(" ^ String.escaped s ^ ")"
    | INFIXOP1 s -> "INFIXOP1(" ^ String.escaped s ^ ")"
    | INFIXOP2 s -> "INFIXOP2(" ^ String.escaped s ^ ")"
    | INFIXOP3 s -> "INFIXOP3(" ^ String.escaped s ^ ")"
    | INFIXOP4 s -> "INFIXOP4(" ^ String.escaped s ^ ")"
    | INHERIT -> "INHERIT"
    | INITIALIZER -> "INITIALIZER"
    | INT s -> "INT(" ^ string_of_int s ^ ")"
    | INT32 s -> "INT32(" ^ Int32.to_string s ^ ")"
    | INT64 s -> "INT64(" ^ Int64.to_string s ^ ")"
    | LABEL s -> "LABEL(" ^ String.escaped s ^ ")"
    | LAZY -> "LAZY"
    | LBRACE -> "LBRACE"
    | LBRACELESS -> "LBRACELESS"
    | LBRACKET -> "LBRACKET"
    | LBRACKETBAR -> "LBRACKETBAR"
    | LBRACKETLESS -> "LBRACKETLESS"
    | LBRACKETGREATER -> "LBRACKETGREATER"
    | LESS -> "LESS"
    | LESSMINUS -> "LESSMINUS"
    | LET -> "LET"
    | LIDENT s -> "LIDENT(" ^ String.escaped s ^ ")"
    | LPAREN -> "LPAREN"
    | MATCH -> "MATCH"
    | METHOD -> "METHOD"
    | MINUS -> "MINUS"
    | MINUSDOT -> "MINUSDOT"
    | MINUSGREATER -> "MINUSGREATER"
    | MODULE -> "MODULE"
    | MUTABLE -> "MUTABLE"
    | NATIVEINT s -> "NATIVEINT(" ^ Nativeint.to_string s ^ ")"
    | NEW -> "NEW"
    | OBJECT -> "OBJECT"
    | OF -> "OF"
    | OPEN -> "OPEN"
    | OPTLABEL s -> "OPTLABEL(" ^ String.escaped s ^ ")"
    | OR -> "OR"
    | PLUS -> "PLUS"
    | PLUSDOT -> "PLUSDOT"
    | PREFIXOP s -> "PREFIXOP(" ^ String.escaped s ^ ")"
    | PRIVATE -> "PRIVATE"
    | QUESTION -> "QUESTION"
    | QUESTIONQUESTION -> "QUESTIONQUESTION"
    | QUOTE -> "QUOTE"
    | RBRACE -> "RBRACE"
    | RBRACKET -> "RBRACKET"
    | REC -> "REC"
    | RPAREN -> "RPAREN"
    | SEMI -> "SEMI"
    | SEMISEMI -> "SEMISEMI"
    | SHARP -> "SHARP"
    | SIG -> "SIG"
    | STAR -> "STAR"
    | STRING s -> "STRING(" ^ String.escaped s ^ ")"
    | STRUCT -> "STRUCT"
    | THEN -> "THEN"
    | TILDE -> "TILDE"
    | TO -> "TO"
    | TRUE -> "TRUE"
    | TRY -> "TRY"
    | TYPE -> "TYPE"
    | UIDENT s -> "UIDENT(" ^ String.escaped s ^ ")"
    | UNDERSCORE -> "UNDERSCORE"
    | VAL -> "VAL"
    | VIRTUAL -> "VIRTUAL"
    | WHEN -> "WHEN"
    | WHILE -> "WHILE"
    | WITH -> "WITH"
    | COMMENT (s,_) -> "COMMENT(" ^ String.escaped s ^ ")"
    | LET_LWT -> "LET_LWT"
    | TRY_LWT -> "TRY_LWT"
    | FINALLY_LWT -> "FINALLY_LWT"
    | MATCH_LWT -> "MATCH_LWT"
    | FOR_LWT -> "FOR_LWT"
    | WHILE_LWT -> "WHILE_LWT"

let print_tokens ?(who="") f a =
  let t = f a in
  (*Printf.eprintf "%s:%s, %!" who (token_to_string t);*)
  t

let rec re_sync lexer buf =
  let open Chunk_parser in
  match lexer buf with
    | SEMISEMI | EOF -> 0
    | INCLUDE | OPEN | LET | TYPE | EXCEPTION -> 1
    | MODULE | END -> 2
    | _ -> re_sync lexer buf

